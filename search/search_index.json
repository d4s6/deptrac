{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is Deptrac? Deptrac is a static code analysis tool for PHP that helps you communicate, visualize and enforce architectural decisions in your projects. You can freely define your architectural layers over classes and which rules should apply to them. For example, you can use Deptrac to ensure that bundles/modules/extensions in your project are truly independent of each other to make them easier to reuse. Deptrac can be used in a CI pipeline to make sure a pull request does not violate any of the architectural rules you defined. With the optional Graphviz formatter you can visualize your layers, rules and violations. Requirements In order to run Deptrac you need at least PHP 8.1. You can analyse projects that require an older PHP version as long as nikic/php-parser can parse it. Installation While you can install Deptrac using composer, we recommend using either the phar installation or PHIVE. This will ensure that Deptrac and its dependencies are bundled together and will not interfere with any of your project's dependencies. PHAR Download the latest deptrac.phar . You can run the phar file using php: php deptrac.phar analyse All examples in this documentation, assume you have the deptrac.phar downloaded in your project's root directory as described above. Feel free to add Deptrac to your PATH (i.e. /usr/local/bin/deptrac ) to make it globally available. curl -LS https://github.com/qossmic/deptrac/releases/download/1.0.2/deptrac.phar -o deptrac.phar # optional sudo chmod +x deptrac.phar sudo mv deptrac.phar /usr/local/bin/deptrac PHIVE You can install Deptrac with Phive phive install -g qossmic/deptrac and accept the key with fingerprint 41DD E075 4745 9FAE CFA1 7813 B8F6 4013 4AB1 782E . To upgrade Deptrac use the following command: phive update -g qossmic/deptrac Composer We do not recommend installing this repository via Composer. Instead, please use the dedicated distribution repository https://github.com/qossmic/deptrac-shim. When you install Deptrac using the qossmic/deptrac-shim package, you will get the benefit of using the phar installation, but you can use it like any other composer dependency, i.e. you run Deptrac like this: composer require qossmic/deptrac-shim php vendor/bin/deptrac analyse Optional Dependency: Graphviz If you want to create graphical diagrams with your class dependencies, you will also need the dot command provided by Graphviz . Graphviz can be installed using common package managers: # for macos + brew brew install graphviz # for ubuntu and debian sudo apt-get install graphviz Graphviz is also available for Windows . Install the current stable release and append the binary path on the environment variable Path (e.g. C:\\Program Files (x86)\\Graphviz2.38\\bin ). Getting Started In order to get started with Deptrac you will need a configuration file. This configuration file is written in YAML and, by default, is stored with the name deptrac.yaml in your project's root directory. Deptrac can generate a template for you, using the init command. php deptrac.phar init The main purpose of this file is: Define in which directories Deptrac will search for classes and which files to exclude. Define your architectural layers using so-called collectors. Define a ruleset describing which layers can communicate with each other. You can find out more about the Core Concepts in the docs. Configuration Let's have a look at the generated file: # deptrac.yaml deptrac: paths: - ./src exclude_files: - '#.*test.*#' layers: - name: Controller collectors: - type: className value: .*Controller.* - name: Repository collectors: - type: className value: .*Repository.* - name: Service collectors: - type: className value: .*Service.* ruleset: Controller: - Service Service: - Repository Repository: ~ By default, Deptrac will search your project's src/ directory for classes and will ignore any files and directory having test in it. We then define three layers by searching for class names in the files found by Deptrac. Any file containing a class with Controller will be grouped in a layer with the same name. The same happens for classes having Repository and Service in their name. It is important to note that the fully qualified class name is used for grouping classes. That means, the collector will take the full namespace with class name into account. The default ruleset will then allow classes in the Controller-layer to communicate - i.e. use classes from - the Service layer. Classes grouped in the Service layer may not use classes from the Controller layer, but they can use classes from the Repository layer. Classes inside the Repository layer may not use any classes from the other two layers. You can learn more about the file in the Configuration reference . Run Deptrac Once you have set up the config file you can run Deptrac to analyse your code and check for violations. If you use the default configuration file, you can type php deptrac.phar , otherwise you will need to specify which command and config file should be used. php deptrac.phar # which is equivalent to php deptrac.phar analyse --config-file=deptrac.yaml If you run php deptrac.phar -v you'll get a more verbose output. The analyse command runs with a caching mechanism for parsed files by default. This can be disabled with the --no-cache option. The generated output will roughly look like this: ----------- -------------------------------------------------------------------------------------------------------------------------------- Reason Repository ----------- -------------------------------------------------------------------------------------------------------------------------------- Violation examples\\MyNamespace\\Repository\\SomeRepository must not depend on examples\\MyNamespace\\Controllers\\SomeController (Controller) /Users/dbr/workspace/qossmic/deptrac/examples/ControllerServiceRepository1/SomeRepository.php:5 ----------- -------------------------------------------------------------------------------------------------------------------------------- -------------------- ----- Report -------------------- ----- Violations 1 Skipped violations 0 Uncovered 0 Allowed 4 Warnings 0 Errors 0 -------------------- ----- This is a report generated by Deptrac. At the top you can see a list of violations, if there are any. A violation means, that a layer uses a layer that is prohibited by the configured ruleset. In this case, a class from the Repository layer uses a class from the Controller layer. The table on the bottom gives you an overview over: how many violations were found. how many violations were skipped, meaning your config contains exceptions. which will not cause Deptrac to return with an error status code, e.g. in CI, when these violations are found. how many classes were found in the directories, that were not assigned to a layer. how many usages between layers were found that do not violate the ruleset. how many warnings where encountered, e.g. because a class is grouped in multiple layers. how many errors were encountered, e.g. when you exclude a violation in your config file but that violation is not encountered. If the output does not match your expectations please take a look at the debugging commands available in Deptrac. You can also change the output format itself by using one of the many provided Output Formatters . Contribute Deptrac is in active development. We are looking for your suggestions and help to make it better. Feel free to open an issue if you encounter bugs, have suggestions or would like to add a new feature to Deptrac. Please feel free to improve this documentation, fix bugs, or work on a suggested feature by making a pull request on GitHub. Don't hesitate to ask for support, if you need help at any point. The Contribution Guide in the documentation contains some advice for making a pull request with code changes. Code of Conduct If you are professional and polite then everything will be alright. Please don't be inconsiderate or mean, or anything in between. Further Documentation Backwards Compatibility - General info on how we approach backwards compatibility Upgrade Guide - List of backwards breaking changes that need to be addressed when upgrading Deptrac to a new version and how to do it. Core Concepts - Explains layers, rules and violations in more details. Configuration - Reference for all available settings in a config file Collectors - Reference for which collectors are available in Deptrac to define your layers. Formatters - Lists the different output formats supported by Deptrac Debugging - Overview of the debug commands Code Of Conduct - Our community standards Contribute - Advice for contributing code changes, e.g. how to run tests or how to build a phar file with your changes that you can use to analyse your projects Security Guide - How to report security vulnerabilities","title":"Home"},{"location":"#what-is-deptrac","text":"Deptrac is a static code analysis tool for PHP that helps you communicate, visualize and enforce architectural decisions in your projects. You can freely define your architectural layers over classes and which rules should apply to them. For example, you can use Deptrac to ensure that bundles/modules/extensions in your project are truly independent of each other to make them easier to reuse. Deptrac can be used in a CI pipeline to make sure a pull request does not violate any of the architectural rules you defined. With the optional Graphviz formatter you can visualize your layers, rules and violations.","title":"What is Deptrac?"},{"location":"#requirements","text":"In order to run Deptrac you need at least PHP 8.1. You can analyse projects that require an older PHP version as long as nikic/php-parser can parse it.","title":"Requirements"},{"location":"#installation","text":"While you can install Deptrac using composer, we recommend using either the phar installation or PHIVE. This will ensure that Deptrac and its dependencies are bundled together and will not interfere with any of your project's dependencies.","title":"Installation"},{"location":"#phar","text":"Download the latest deptrac.phar . You can run the phar file using php: php deptrac.phar analyse All examples in this documentation, assume you have the deptrac.phar downloaded in your project's root directory as described above. Feel free to add Deptrac to your PATH (i.e. /usr/local/bin/deptrac ) to make it globally available. curl -LS https://github.com/qossmic/deptrac/releases/download/1.0.2/deptrac.phar -o deptrac.phar # optional sudo chmod +x deptrac.phar sudo mv deptrac.phar /usr/local/bin/deptrac","title":"PHAR"},{"location":"#phive","text":"You can install Deptrac with Phive phive install -g qossmic/deptrac and accept the key with fingerprint 41DD E075 4745 9FAE CFA1 7813 B8F6 4013 4AB1 782E . To upgrade Deptrac use the following command: phive update -g qossmic/deptrac","title":"PHIVE"},{"location":"#composer","text":"We do not recommend installing this repository via Composer. Instead, please use the dedicated distribution repository https://github.com/qossmic/deptrac-shim. When you install Deptrac using the qossmic/deptrac-shim package, you will get the benefit of using the phar installation, but you can use it like any other composer dependency, i.e. you run Deptrac like this: composer require qossmic/deptrac-shim php vendor/bin/deptrac analyse","title":"Composer"},{"location":"#optional-dependency-graphviz","text":"If you want to create graphical diagrams with your class dependencies, you will also need the dot command provided by Graphviz . Graphviz can be installed using common package managers: # for macos + brew brew install graphviz # for ubuntu and debian sudo apt-get install graphviz Graphviz is also available for Windows . Install the current stable release and append the binary path on the environment variable Path (e.g. C:\\Program Files (x86)\\Graphviz2.38\\bin ).","title":"Optional Dependency: Graphviz"},{"location":"#getting-started","text":"In order to get started with Deptrac you will need a configuration file. This configuration file is written in YAML and, by default, is stored with the name deptrac.yaml in your project's root directory. Deptrac can generate a template for you, using the init command. php deptrac.phar init The main purpose of this file is: Define in which directories Deptrac will search for classes and which files to exclude. Define your architectural layers using so-called collectors. Define a ruleset describing which layers can communicate with each other. You can find out more about the Core Concepts in the docs.","title":"Getting Started"},{"location":"#configuration","text":"Let's have a look at the generated file: # deptrac.yaml deptrac: paths: - ./src exclude_files: - '#.*test.*#' layers: - name: Controller collectors: - type: className value: .*Controller.* - name: Repository collectors: - type: className value: .*Repository.* - name: Service collectors: - type: className value: .*Service.* ruleset: Controller: - Service Service: - Repository Repository: ~ By default, Deptrac will search your project's src/ directory for classes and will ignore any files and directory having test in it. We then define three layers by searching for class names in the files found by Deptrac. Any file containing a class with Controller will be grouped in a layer with the same name. The same happens for classes having Repository and Service in their name. It is important to note that the fully qualified class name is used for grouping classes. That means, the collector will take the full namespace with class name into account. The default ruleset will then allow classes in the Controller-layer to communicate - i.e. use classes from - the Service layer. Classes grouped in the Service layer may not use classes from the Controller layer, but they can use classes from the Repository layer. Classes inside the Repository layer may not use any classes from the other two layers. You can learn more about the file in the Configuration reference .","title":"Configuration"},{"location":"#run-deptrac","text":"Once you have set up the config file you can run Deptrac to analyse your code and check for violations. If you use the default configuration file, you can type php deptrac.phar , otherwise you will need to specify which command and config file should be used. php deptrac.phar # which is equivalent to php deptrac.phar analyse --config-file=deptrac.yaml If you run php deptrac.phar -v you'll get a more verbose output. The analyse command runs with a caching mechanism for parsed files by default. This can be disabled with the --no-cache option. The generated output will roughly look like this: ----------- -------------------------------------------------------------------------------------------------------------------------------- Reason Repository ----------- -------------------------------------------------------------------------------------------------------------------------------- Violation examples\\MyNamespace\\Repository\\SomeRepository must not depend on examples\\MyNamespace\\Controllers\\SomeController (Controller) /Users/dbr/workspace/qossmic/deptrac/examples/ControllerServiceRepository1/SomeRepository.php:5 ----------- -------------------------------------------------------------------------------------------------------------------------------- -------------------- ----- Report -------------------- ----- Violations 1 Skipped violations 0 Uncovered 0 Allowed 4 Warnings 0 Errors 0 -------------------- ----- This is a report generated by Deptrac. At the top you can see a list of violations, if there are any. A violation means, that a layer uses a layer that is prohibited by the configured ruleset. In this case, a class from the Repository layer uses a class from the Controller layer. The table on the bottom gives you an overview over: how many violations were found. how many violations were skipped, meaning your config contains exceptions. which will not cause Deptrac to return with an error status code, e.g. in CI, when these violations are found. how many classes were found in the directories, that were not assigned to a layer. how many usages between layers were found that do not violate the ruleset. how many warnings where encountered, e.g. because a class is grouped in multiple layers. how many errors were encountered, e.g. when you exclude a violation in your config file but that violation is not encountered. If the output does not match your expectations please take a look at the debugging commands available in Deptrac. You can also change the output format itself by using one of the many provided Output Formatters .","title":"Run Deptrac"},{"location":"#contribute","text":"Deptrac is in active development. We are looking for your suggestions and help to make it better. Feel free to open an issue if you encounter bugs, have suggestions or would like to add a new feature to Deptrac. Please feel free to improve this documentation, fix bugs, or work on a suggested feature by making a pull request on GitHub. Don't hesitate to ask for support, if you need help at any point. The Contribution Guide in the documentation contains some advice for making a pull request with code changes.","title":"Contribute"},{"location":"#code-of-conduct","text":"If you are professional and polite then everything will be alright. Please don't be inconsiderate or mean, or anything in between.","title":"Code of Conduct"},{"location":"#further-documentation","text":"Backwards Compatibility - General info on how we approach backwards compatibility Upgrade Guide - List of backwards breaking changes that need to be addressed when upgrading Deptrac to a new version and how to do it. Core Concepts - Explains layers, rules and violations in more details. Configuration - Reference for all available settings in a config file Collectors - Reference for which collectors are available in Deptrac to define your layers. Formatters - Lists the different output formats supported by Deptrac Debugging - Overview of the debug commands Code Of Conduct - Our community standards Contribute - Advice for contributing code changes, e.g. how to run tests or how to build a phar file with your changes that you can use to analyse your projects Security Guide - How to report security vulnerabilities","title":"Further Documentation"},{"location":"CODE_OF_CONDUCT/","text":"Code of Conduct If you are professional and polite, then everything will be alright. Please don't be inconsiderate and mean, or anything in between. We do not have a formal code of conduct. That being said, we do not tolerate harassment and will take action against any individual who is not acting professionally. This can range from reprimanding them privately to blocking them from interacting with the repository. QOSSMIC as owner is responsible for upholding the code of conduct and should be contacted if you have any issues. Please use the following email for this: wecare@qossmic.com","title":"Code of Conduct"},{"location":"CODE_OF_CONDUCT/#code-of-conduct","text":"If you are professional and polite, then everything will be alright. Please don't be inconsiderate and mean, or anything in between. We do not have a formal code of conduct. That being said, we do not tolerate harassment and will take action against any individual who is not acting professionally. This can range from reprimanding them privately to blocking them from interacting with the repository. QOSSMIC as owner is responsible for upholding the code of conduct and should be contacted if you have any issues. Please use the following email for this: wecare@qossmic.com","title":"Code of Conduct"},{"location":"CONTRIBUTING/","text":"Contributing to Deptrac There are many ways to contribute to Deptrac, from helping others with their issues, improving the documentation to fixing bugs & adding new features. The maintainers and contributors will help you best as they can, when you have questions or troubles. Feel free to reach out. When you want to add a new feature to Deptrac, please make sure to open an issue first to let others know who is working on it and prevent similar or conflicting pull requests. We are always happy to expand the possibilities of Deptrac to better fit the need of anyone who uses it. Before we merge changes, we have to decide whether we can maintain them without taking away resources needed elsewhere. Unfortunately, that means we have to reject some change requests. Opening an issue before you start working on any new feature will make sure that your merge request can be accepted. Requirements PHP in version 8.1 or above Composer make Installing tools You can install all tools needed for developing Deptrac using the Makefile by running the following command: make composer-install Pipeline Any merge request must pass our build pipeline which consists of the following: Unit Tests for all supported PHP-versions Check for coding guidelines Static code analysis with phpstan and psalm End 2 End-tests, ensuring deptrac.phar can be built You can use the provided Makefile to execute these steps locally. The make command is supported by most major operating systems, but you might need to install it first. The Makefile will use Composer to install the required tools like PHPUnit, Psalm or PHPStan. If you don't want to use Composer or the Makefile you will need to install them yourself. Tests You can run the unit tests locally using the provided Makefile make tests This will run phpunit to make sure the tests pass. We recommend running the tests once before you make any changes to ensure they work on your system. This way you can be sure that any failing test is not caused by a pre-existing problem. Code style You can check if your code changes are in line with our coding guidelines using php-cs-fixer. make php-cs-check This will show you any code style violations that are also reported on Github. You can automatically fix them by running: make php-cs-fix Static code analysis In order to perform static code analysis for your changes you can run: make phpstan make psalm We also run a tool called infection for mutation testing: make infection Build Deptrac You can build the deptrac.phar both to ensure it works, as well as for using it to analyse your existing projects to see if your changes work as expected. make build This will create an executable file deptrac.phar in the current directory. Deptrac Engine (Internals) The internal Deptrac engine consists of several parts, some of those can be influenced by configuration or extensions ( Analyser , InputCollector , Dependency , Layer ), while others cannot ( Ast ). To give you a brief overview of how the pieces lock together, a diagram of DependencyLayerAnalyser run: sequenceDiagram participant A as Analyser participant I as InputCollector participant As as Ast participant D as Dependency participant L as Layer A->>I: Collect files to analyse I->>A: List of files to analyse A->>As: Create Ast for collected files alt Cached As->>As: Load cached \"AstMap\" else Not cached note over As: Will collect all possible connections <br/> regradless of deptrac configuration As->>As: Apply \"ReferenceExtractors\" end As->>A: \"AstMap\" for all files A->>D: Resolve all dependencies between Ast Nodes D->>D: Apply all registered \"DependencyEmmiters\" D->>A: \"DependencyList\" of all dependencies loop for each dependency A->>L: Resolve layers for both sides of the dependency L->>A: One or more layers for each side A->>A: Build \"Result\" based on defined ruleset end InputCollector Is responsible for collecting all the files to be analysed. By default, it uses the deptrac.paths section of the configuration to determine which files to collect and [ exclude_files ][depfile.md#exclude_files] to exclude filenames matching the specified patterns. Ast The Ast module is responsible for parsing all the provided files and building an Abstract Syntax Tree (AST) for those files. The AstLoader fetches everything, even if you have configured Deptrac to ignore some parts of the file, e.g. because the class is not in any layer or you configured types to ignore certain things like use-statements. Filtering the found dependencies happens in the next phase. The main part of the parsing is done in the FileReferenceVisior . This file is primarily concerned with keeping the appropriate scope (are you inside a class or a function) and also keeping track of currently applicable @template annotations. You can extend the functionality by adding extractors implementing the ReferenceExtractorInterface to build more connections between the nodes. The result is an AstMap containing all occurrences of found files, classes and functions. This is what gets saved into the .deptrac.cache file. Dependency The Dependency module is concerned with taking the generated AstMap and converting it into a DependencyList of applicable dependencies between nodes based on the deptrac.analyser.types section of the configuration. Each type corresponds to an emitter implementing DependencyEmitterInterface . Layers As the name suggests, this module resolves what layers should each token be a part of. It leverages the collectors defined in the deptrac.layers section of the configuration. Analyser The Analyser orchestrates between these modules. It calls the InputCollector , Ast and Dependency modules to generate a list of relevant dependencies matched to their layers, compares them against the deptrac.ruleset section of the configuration and finally generates a Result , which will be returned in the output. The Result is a collection of Allowed , Error , Warning , Violation , Skipped and Uncovered Rules. Those are then processed by the OutputFormatters to give you the desired output you can see when you call a command.","title":"Contributing"},{"location":"CONTRIBUTING/#contributing-to-deptrac","text":"There are many ways to contribute to Deptrac, from helping others with their issues, improving the documentation to fixing bugs & adding new features. The maintainers and contributors will help you best as they can, when you have questions or troubles. Feel free to reach out. When you want to add a new feature to Deptrac, please make sure to open an issue first to let others know who is working on it and prevent similar or conflicting pull requests. We are always happy to expand the possibilities of Deptrac to better fit the need of anyone who uses it. Before we merge changes, we have to decide whether we can maintain them without taking away resources needed elsewhere. Unfortunately, that means we have to reject some change requests. Opening an issue before you start working on any new feature will make sure that your merge request can be accepted.","title":"Contributing to Deptrac"},{"location":"CONTRIBUTING/#requirements","text":"PHP in version 8.1 or above Composer make","title":"Requirements"},{"location":"CONTRIBUTING/#installing-tools","text":"You can install all tools needed for developing Deptrac using the Makefile by running the following command: make composer-install","title":"Installing tools"},{"location":"CONTRIBUTING/#pipeline","text":"Any merge request must pass our build pipeline which consists of the following: Unit Tests for all supported PHP-versions Check for coding guidelines Static code analysis with phpstan and psalm End 2 End-tests, ensuring deptrac.phar can be built You can use the provided Makefile to execute these steps locally. The make command is supported by most major operating systems, but you might need to install it first. The Makefile will use Composer to install the required tools like PHPUnit, Psalm or PHPStan. If you don't want to use Composer or the Makefile you will need to install them yourself.","title":"Pipeline"},{"location":"CONTRIBUTING/#tests","text":"You can run the unit tests locally using the provided Makefile make tests This will run phpunit to make sure the tests pass. We recommend running the tests once before you make any changes to ensure they work on your system. This way you can be sure that any failing test is not caused by a pre-existing problem.","title":"Tests"},{"location":"CONTRIBUTING/#code-style","text":"You can check if your code changes are in line with our coding guidelines using php-cs-fixer. make php-cs-check This will show you any code style violations that are also reported on Github. You can automatically fix them by running: make php-cs-fix","title":"Code style"},{"location":"CONTRIBUTING/#static-code-analysis","text":"In order to perform static code analysis for your changes you can run: make phpstan make psalm We also run a tool called infection for mutation testing: make infection","title":"Static code analysis"},{"location":"CONTRIBUTING/#build-deptrac","text":"You can build the deptrac.phar both to ensure it works, as well as for using it to analyse your existing projects to see if your changes work as expected. make build This will create an executable file deptrac.phar in the current directory.","title":"Build Deptrac"},{"location":"CONTRIBUTING/#deptrac-engine-internals","text":"The internal Deptrac engine consists of several parts, some of those can be influenced by configuration or extensions ( Analyser , InputCollector , Dependency , Layer ), while others cannot ( Ast ). To give you a brief overview of how the pieces lock together, a diagram of DependencyLayerAnalyser run: sequenceDiagram participant A as Analyser participant I as InputCollector participant As as Ast participant D as Dependency participant L as Layer A->>I: Collect files to analyse I->>A: List of files to analyse A->>As: Create Ast for collected files alt Cached As->>As: Load cached \"AstMap\" else Not cached note over As: Will collect all possible connections <br/> regradless of deptrac configuration As->>As: Apply \"ReferenceExtractors\" end As->>A: \"AstMap\" for all files A->>D: Resolve all dependencies between Ast Nodes D->>D: Apply all registered \"DependencyEmmiters\" D->>A: \"DependencyList\" of all dependencies loop for each dependency A->>L: Resolve layers for both sides of the dependency L->>A: One or more layers for each side A->>A: Build \"Result\" based on defined ruleset end","title":"Deptrac Engine (Internals)"},{"location":"CONTRIBUTING/#inputcollector","text":"Is responsible for collecting all the files to be analysed. By default, it uses the deptrac.paths section of the configuration to determine which files to collect and [ exclude_files ][depfile.md#exclude_files] to exclude filenames matching the specified patterns.","title":"InputCollector"},{"location":"CONTRIBUTING/#ast","text":"The Ast module is responsible for parsing all the provided files and building an Abstract Syntax Tree (AST) for those files. The AstLoader fetches everything, even if you have configured Deptrac to ignore some parts of the file, e.g. because the class is not in any layer or you configured types to ignore certain things like use-statements. Filtering the found dependencies happens in the next phase. The main part of the parsing is done in the FileReferenceVisior . This file is primarily concerned with keeping the appropriate scope (are you inside a class or a function) and also keeping track of currently applicable @template annotations. You can extend the functionality by adding extractors implementing the ReferenceExtractorInterface to build more connections between the nodes. The result is an AstMap containing all occurrences of found files, classes and functions. This is what gets saved into the .deptrac.cache file.","title":"Ast"},{"location":"CONTRIBUTING/#dependency","text":"The Dependency module is concerned with taking the generated AstMap and converting it into a DependencyList of applicable dependencies between nodes based on the deptrac.analyser.types section of the configuration. Each type corresponds to an emitter implementing DependencyEmitterInterface .","title":"Dependency"},{"location":"CONTRIBUTING/#layers","text":"As the name suggests, this module resolves what layers should each token be a part of. It leverages the collectors defined in the deptrac.layers section of the configuration.","title":"Layers"},{"location":"CONTRIBUTING/#analyser","text":"The Analyser orchestrates between these modules. It calls the InputCollector , Ast and Dependency modules to generate a list of relevant dependencies matched to their layers, compares them against the deptrac.ruleset section of the configuration and finally generates a Result , which will be returned in the output. The Result is a collection of Allowed , Error , Warning , Violation , Skipped and Uncovered Rules. Those are then processed by the OutputFormatters to give you the desired output you can see when you call a command.","title":"Analyser"},{"location":"SECURITY/","text":"Security Guideline This document explains how Deptrac security issues are handled by the maintainers. Reporting a security issue If you think you have found a security issue in Deptrac, we ask you not to use the bug tracker and to not publish it publicly. Instead, all security issues must be sent to security@qossmic.com . Security bug bounties Deptrac is an Open-Source project where most of the work is done by volunteers. We appreciate that developers are trying to find security issues in Deptrac and report them responsibly, but we are currently unable to pay bug bounties. Process In case of an incident being reported, we will... try to confirm the vulnerability. send an acknowledgement to the reporter, if the issue is confirmed start working on a patch prepare a security advisory to be published with the patch send the patch and advisory to the reporter for review apply the patch to all supported versions of Deptrac release a new version of Deptrac with the applied patch publish the advisory","title":"Security"},{"location":"SECURITY/#security-guideline","text":"This document explains how Deptrac security issues are handled by the maintainers.","title":"Security Guideline"},{"location":"SECURITY/#reporting-a-security-issue","text":"If you think you have found a security issue in Deptrac, we ask you not to use the bug tracker and to not publish it publicly. Instead, all security issues must be sent to security@qossmic.com .","title":"Reporting a security issue"},{"location":"SECURITY/#security-bug-bounties","text":"Deptrac is an Open-Source project where most of the work is done by volunteers. We appreciate that developers are trying to find security issues in Deptrac and report them responsibly, but we are currently unable to pay bug bounties.","title":"Security bug bounties"},{"location":"SECURITY/#process","text":"In case of an incident being reported, we will... try to confirm the vulnerability. send an acknowledgement to the reporter, if the issue is confirmed start working on a patch prepare a security advisory to be published with the patch send the patch and advisory to the reporter for review apply the patch to all supported versions of Deptrac release a new version of Deptrac with the applied patch publish the advisory","title":"Process"},{"location":"bc_policy/","text":"Backwards Compatibility Policy Deptrac adheres to Semantic Versioning 2.0.0 . That means, we will not introduce any breaking change in a minor or patch release starting with the first stable release 1.0.0. Within the 0.x.y major release, we may introduce breaking changes in minor releases. Given a version number MAJOR.MINOR.PATCH, increment the: MAJOR version when you make incompatible API changes MINOR version when you add functionality in a backwards compatible manner PATCH version when you make backwards compatible bug fixes First and foremost Deptrac is a command line utility, not a library. This governs what we consider a breaking change and might differ from your expectations from other packages. The following policy outlines what we consider breaking changes. We strongly suggest reading the Upgrade Guide for information on any planned breaking changes and how to deal with them. If you encounter a breaking change that is not documented, feel free to open an issue. Security Security fixes may break backwards compatibility at any point. For more details on security related issues, please refer to the Security Guide . Commands Deptrac provides a series of commands such as analyse . The following things are considered breaking changes: Renaming or removing the command Renaming or removing options or arguments Changing the argument order Changing any of the expected values provided by Deptrac, e.g. formatter names Output (with some exceptions outlined below) Please notice, that the output is partly controlled by your system, e.g. line length. You might experience different output on different systems. However, you should be able to expect the same output on the same machine between version upgrades. We might make minor changes, such as fixing typos in a patch or minor release, if we assume the impact to users will be low. Generally speaking, formatters targeting CI systems, such as the Github-formatter, will be treated more strictly than for example the graphviz dot formatter, which is assumed to not be used directly in a CI pipeline. Configuration Users of Deptrac should expect their initial configuration to work across newer minor and patch releases. As such, we will not make any breaking changes to configuration. Adding new (optional) configuration sections is allowed, but we will not alter existing fields and their expected types. You can expect the following breaking changes only to happen in a major release: Renaming or moving the default config file(name) Renaming or removing fields Making a previously optional field required Changing types of the config values Code The following backwards compatibility promise extends only to code in the Qossmic\\Deptrac\\Contract\\ namespace. Other code may change within a major release, unless it is marked explicitly as @public . Conversely, if anything in the Contract namespace is marked as @internal the BC promise does not apply. We try to follow Symfony's backwards compatibility promise as closely as possible. Please refer to their guide for a detailed explanation. In short, our interfaces and classes will not change unexpectedly within a major release. Features Within a major version we will not unexpectedly remove or change features, e.g. remove a collectors arguments or its name or removing it entirely. Deptrac provides a series of extension points, e.g. events to hook into. You can expect these events to not be renamed or existing arguments, you might be using, to be altered within a major release.","title":"Backwards Compatibility"},{"location":"bc_policy/#backwards-compatibility-policy","text":"Deptrac adheres to Semantic Versioning 2.0.0 . That means, we will not introduce any breaking change in a minor or patch release starting with the first stable release 1.0.0. Within the 0.x.y major release, we may introduce breaking changes in minor releases. Given a version number MAJOR.MINOR.PATCH, increment the: MAJOR version when you make incompatible API changes MINOR version when you add functionality in a backwards compatible manner PATCH version when you make backwards compatible bug fixes First and foremost Deptrac is a command line utility, not a library. This governs what we consider a breaking change and might differ from your expectations from other packages. The following policy outlines what we consider breaking changes. We strongly suggest reading the Upgrade Guide for information on any planned breaking changes and how to deal with them. If you encounter a breaking change that is not documented, feel free to open an issue.","title":"Backwards Compatibility Policy"},{"location":"bc_policy/#security","text":"Security fixes may break backwards compatibility at any point. For more details on security related issues, please refer to the Security Guide .","title":"Security"},{"location":"bc_policy/#commands","text":"Deptrac provides a series of commands such as analyse . The following things are considered breaking changes: Renaming or removing the command Renaming or removing options or arguments Changing the argument order Changing any of the expected values provided by Deptrac, e.g. formatter names Output (with some exceptions outlined below) Please notice, that the output is partly controlled by your system, e.g. line length. You might experience different output on different systems. However, you should be able to expect the same output on the same machine between version upgrades. We might make minor changes, such as fixing typos in a patch or minor release, if we assume the impact to users will be low. Generally speaking, formatters targeting CI systems, such as the Github-formatter, will be treated more strictly than for example the graphviz dot formatter, which is assumed to not be used directly in a CI pipeline.","title":"Commands"},{"location":"bc_policy/#configuration","text":"Users of Deptrac should expect their initial configuration to work across newer minor and patch releases. As such, we will not make any breaking changes to configuration. Adding new (optional) configuration sections is allowed, but we will not alter existing fields and their expected types. You can expect the following breaking changes only to happen in a major release: Renaming or moving the default config file(name) Renaming or removing fields Making a previously optional field required Changing types of the config values","title":"Configuration"},{"location":"bc_policy/#code","text":"The following backwards compatibility promise extends only to code in the Qossmic\\Deptrac\\Contract\\ namespace. Other code may change within a major release, unless it is marked explicitly as @public . Conversely, if anything in the Contract namespace is marked as @internal the BC promise does not apply. We try to follow Symfony's backwards compatibility promise as closely as possible. Please refer to their guide for a detailed explanation. In short, our interfaces and classes will not change unexpectedly within a major release.","title":"Code"},{"location":"bc_policy/#features","text":"Within a major version we will not unexpectedly remove or change features, e.g. remove a collectors arguments or its name or removing it entirely. Deptrac provides a series of extension points, e.g. events to hook into. You can expect these events to not be renamed or existing arguments, you might be using, to be altered within a major release.","title":"Features"},{"location":"collectors/","text":"Collectors Collectors decide if a node (typically a class) is part of a layer. You can use multiple different collectors for a layer. attribute Collector The attribute collector finds all class-likes, functions or files using the provided attribute. You can provide the full attribute name or a substring that should be matched. deptrac: layers: - name: Entities collectors: - type: attribute value: Doctrine\\ORM\\Mapping\\Entity bool Collector The bool collector allows combining other collectors with or without negation. deptrac: layers: - name: Asset collectors: - type: bool must: - type: classLike value: .*Foo\\\\.* - type: classLike value: .*\\\\Asset.* must_not: - type: classLike value: .*Assetic.* Every class contains Foo\\ AND \\Asset and NOT Assetic , will become a part of the Asset layer. class Collector The class collector allows collecting only classes by matching their fully qualified name to a simplified regular expression. Any match will be added to the assigned layer. deptrac: layers: - name: Provider collectors: - type: class value: .*Provider.* Every class name that matches the regular expression becomes a part of the Provider layer. This collector has predefined delimiters and modifier: /YOUR_EXPRESSION/i classLike Collector The classLike collector allows collecting classes and anything similar to classes like interfaces, traits or enums, by matching their fully qualified name to a simplified regular expression. Any match will be added to the assigned layer. deptrac: layers: - name: Domain collectors: - type: classLike value: .*Domain.* Every classLike name that matches the regular expression becomes a part of the domain layer. This collector has predefined delimiters and modifier: /YOUR_EXPRESSION/i classNameRegex Collector The classNameRegex collector allows collecting classes by matching their fully qualified name to a regular expression. Any matching class will be added to the assigned layer. deptrac: layers: - name: Controller collectors: - type: classNameRegex value: '#.*Controller.*#' Every class name that matches the regular expression becomes a part of the controller layer. directory Collector The directory collector allows collecting classes by matching their file path they are declared in to a simplified regular expression. Any matching class will be added to the assigned layer. deptrac: layers: - name: Controller collectors: - type: directory value: src/Controller/.* Every file path that matches the regular expression src/Controller/.* becomes a part of the controller layer. This collector has predefined delimiters and modifier: #YOUR_EXPRESSION#i extends Collector The extends collector allows collecting classes extending a specified class by matching recursively for a fully qualified class or interface name. deptrac: layers: - name: Foo collectors: - type: extends value: 'App\\SomeClass' functionName Collector The functionName collector allows collecting functions by matching their fully qualified name to a simplified regular expression. Any matching function will be added to the assigned layer. deptrac: layers: - name: Foo collectors: - type: functionName value: .*array_.* glob Collector The glob collector finds all files matching the provided glob pattern. deptrac: layers: - name: Repositories collectors: - type: glob value: src/Modules/**/Repository implements Collector The implements collector allows collecting classes implementing a specified interface by matching recursively for a fully qualified interface name. deptrac: layers: - name: Foo collectors: - type: implements value: 'App\\SomeInterface' interface Collector The interface collector allows collecting only interfaces by matching their fully qualified name to a simplified regular expression. Any matching interface will be added to the assigned layer. deptrac: layers: - name: Contracts collectors: - type: interface value: .*Contracts.* Every interface name that matches the regular expression becomes a part of the Interfaces layer. This collector has predefined delimiters and modifier: /YOUR_EXPRESSION/i inherits Collector The inherits collector allows collecting classes inheriting from a specified class, whether by implementing an interface, extending another class or by using a trait, by matching recursively for a fully qualified class name. deptrac: layers: - name: Foo collectors: - type: inherits value: 'App\\SomeInterface' layer Collector This collector collects all the tokens collected by another layer. It is not very useful by itself (unless you want to have tokens in multiple layers), but it is very useful to exclude classes in combination with the bool Collector : deptrac: layers: - name: SubDomain collectors: - type: directory value: src/Domain/Subdomain/.* - name: Domain collectors: - type: bool must: - type: directory value: src/Domain/.* must_not: - type: layer layer: SubDomain method Collector The method collector allows collecting classes by matching their methods name to a regular expression. Any matching class will be added to the assigned layer. deptrac: layers: - name: Foo services collectors: - type: method value: .*foo Every class having a method that matches the regular expression .*foo , e.g. getFoo() or setFoo() becomes a part of the Foo services layer. superglobal Collector The superglobal collector allows collecting superglobal PHP variables matching the specified superglobal name. deptrac: layers: - name: Foo collectors: - type: superglobal value: - _POST - _GET trait Collector The trait collector allows collecting only traits by matching their fully qualified name to a simplified regular expression. Any matching trait will be added to the assigned layer. deptrac: layers: - name: Traits collectors: - type: trait value: .*Traits.* Every trait name that matches the regular expression becomes a part of the traits layer. This collector has predefined delimiters and modifier: /YOUR_EXPRESSION/i uses Collector The uses collector allows collecting classes using a specified trait by matching recursively for a fully qualified trait name. deptrac: layers: - name: Foo collectors: - type: uses value: 'App\\SomeTrait' PHP Internal Collector The PHP Internal collector collects PHP defined classes and functions including those loaded with PHP extensions. deptrac: layers: - name: Foo collectors: - type: php_internal value: ^reset$ Custom Collectors You can create custom collectors in your project by implementing the Qossmic\\Deptrac\\Collector\\CollectorInterface . As soon as an unknown collector is referenced in the config file Deptrac will try to load the class in your project. With this you can create collectors specific for your use case. If you would like to make your collector available to others, feel free to contribute it by making a pull request. Extra collector configuration Any collector can also specify parameter private:true like this: deptrac: layers: - name: Foo collectors: - type: uses value: 'App\\SomeTrait' private: true This means that tokens collected by this specific collector can be referenced only by other tokens in the same layer. References from other layers will be considered violations, even if they would normally be allowed by configured ruleset. This can be useful at least in 2 cases: - External library that should be used only by one particular layer - In this case, you might via vendor include a library that should be used only by this particular layer and nobody else. - Layer that has a public API and private implementation - You might want to provide only a few classes to be available to use by other layers (public API) that call the internal implementation of the layer that on the other hand should not be available to anybody else other than the public API of the layer.","title":"Collectors"},{"location":"collectors/#collectors","text":"Collectors decide if a node (typically a class) is part of a layer. You can use multiple different collectors for a layer.","title":"Collectors"},{"location":"collectors/#attribute-collector","text":"The attribute collector finds all class-likes, functions or files using the provided attribute. You can provide the full attribute name or a substring that should be matched. deptrac: layers: - name: Entities collectors: - type: attribute value: Doctrine\\ORM\\Mapping\\Entity","title":"attribute Collector"},{"location":"collectors/#bool-collector","text":"The bool collector allows combining other collectors with or without negation. deptrac: layers: - name: Asset collectors: - type: bool must: - type: classLike value: .*Foo\\\\.* - type: classLike value: .*\\\\Asset.* must_not: - type: classLike value: .*Assetic.* Every class contains Foo\\ AND \\Asset and NOT Assetic , will become a part of the Asset layer.","title":"bool Collector"},{"location":"collectors/#class-collector","text":"The class collector allows collecting only classes by matching their fully qualified name to a simplified regular expression. Any match will be added to the assigned layer. deptrac: layers: - name: Provider collectors: - type: class value: .*Provider.* Every class name that matches the regular expression becomes a part of the Provider layer. This collector has predefined delimiters and modifier: /YOUR_EXPRESSION/i","title":"class Collector"},{"location":"collectors/#classlike-collector","text":"The classLike collector allows collecting classes and anything similar to classes like interfaces, traits or enums, by matching their fully qualified name to a simplified regular expression. Any match will be added to the assigned layer. deptrac: layers: - name: Domain collectors: - type: classLike value: .*Domain.* Every classLike name that matches the regular expression becomes a part of the domain layer. This collector has predefined delimiters and modifier: /YOUR_EXPRESSION/i","title":"classLike Collector"},{"location":"collectors/#classnameregex-collector","text":"The classNameRegex collector allows collecting classes by matching their fully qualified name to a regular expression. Any matching class will be added to the assigned layer. deptrac: layers: - name: Controller collectors: - type: classNameRegex value: '#.*Controller.*#' Every class name that matches the regular expression becomes a part of the controller layer.","title":"classNameRegex Collector"},{"location":"collectors/#directory-collector","text":"The directory collector allows collecting classes by matching their file path they are declared in to a simplified regular expression. Any matching class will be added to the assigned layer. deptrac: layers: - name: Controller collectors: - type: directory value: src/Controller/.* Every file path that matches the regular expression src/Controller/.* becomes a part of the controller layer. This collector has predefined delimiters and modifier: #YOUR_EXPRESSION#i","title":"directory Collector"},{"location":"collectors/#extends-collector","text":"The extends collector allows collecting classes extending a specified class by matching recursively for a fully qualified class or interface name. deptrac: layers: - name: Foo collectors: - type: extends value: 'App\\SomeClass'","title":"extends Collector"},{"location":"collectors/#functionname-collector","text":"The functionName collector allows collecting functions by matching their fully qualified name to a simplified regular expression. Any matching function will be added to the assigned layer. deptrac: layers: - name: Foo collectors: - type: functionName value: .*array_.*","title":"functionName Collector"},{"location":"collectors/#glob-collector","text":"The glob collector finds all files matching the provided glob pattern. deptrac: layers: - name: Repositories collectors: - type: glob value: src/Modules/**/Repository","title":"glob Collector"},{"location":"collectors/#implements-collector","text":"The implements collector allows collecting classes implementing a specified interface by matching recursively for a fully qualified interface name. deptrac: layers: - name: Foo collectors: - type: implements value: 'App\\SomeInterface'","title":"implements Collector"},{"location":"collectors/#interface-collector","text":"The interface collector allows collecting only interfaces by matching their fully qualified name to a simplified regular expression. Any matching interface will be added to the assigned layer. deptrac: layers: - name: Contracts collectors: - type: interface value: .*Contracts.* Every interface name that matches the regular expression becomes a part of the Interfaces layer. This collector has predefined delimiters and modifier: /YOUR_EXPRESSION/i","title":"interface Collector"},{"location":"collectors/#inherits-collector","text":"The inherits collector allows collecting classes inheriting from a specified class, whether by implementing an interface, extending another class or by using a trait, by matching recursively for a fully qualified class name. deptrac: layers: - name: Foo collectors: - type: inherits value: 'App\\SomeInterface'","title":"inherits Collector"},{"location":"collectors/#layer-collector","text":"This collector collects all the tokens collected by another layer. It is not very useful by itself (unless you want to have tokens in multiple layers), but it is very useful to exclude classes in combination with the bool Collector : deptrac: layers: - name: SubDomain collectors: - type: directory value: src/Domain/Subdomain/.* - name: Domain collectors: - type: bool must: - type: directory value: src/Domain/.* must_not: - type: layer layer: SubDomain","title":"layer Collector"},{"location":"collectors/#method-collector","text":"The method collector allows collecting classes by matching their methods name to a regular expression. Any matching class will be added to the assigned layer. deptrac: layers: - name: Foo services collectors: - type: method value: .*foo Every class having a method that matches the regular expression .*foo , e.g. getFoo() or setFoo() becomes a part of the Foo services layer.","title":"method Collector"},{"location":"collectors/#superglobal-collector","text":"The superglobal collector allows collecting superglobal PHP variables matching the specified superglobal name. deptrac: layers: - name: Foo collectors: - type: superglobal value: - _POST - _GET","title":"superglobal Collector"},{"location":"collectors/#trait-collector","text":"The trait collector allows collecting only traits by matching their fully qualified name to a simplified regular expression. Any matching trait will be added to the assigned layer. deptrac: layers: - name: Traits collectors: - type: trait value: .*Traits.* Every trait name that matches the regular expression becomes a part of the traits layer. This collector has predefined delimiters and modifier: /YOUR_EXPRESSION/i","title":"trait Collector"},{"location":"collectors/#uses-collector","text":"The uses collector allows collecting classes using a specified trait by matching recursively for a fully qualified trait name. deptrac: layers: - name: Foo collectors: - type: uses value: 'App\\SomeTrait'","title":"uses Collector"},{"location":"collectors/#php-internal-collector","text":"The PHP Internal collector collects PHP defined classes and functions including those loaded with PHP extensions. deptrac: layers: - name: Foo collectors: - type: php_internal value: ^reset$","title":"PHP Internal Collector"},{"location":"collectors/#custom-collectors","text":"You can create custom collectors in your project by implementing the Qossmic\\Deptrac\\Collector\\CollectorInterface . As soon as an unknown collector is referenced in the config file Deptrac will try to load the class in your project. With this you can create collectors specific for your use case. If you would like to make your collector available to others, feel free to contribute it by making a pull request.","title":"Custom Collectors"},{"location":"collectors/#extra-collector-configuration","text":"Any collector can also specify parameter private:true like this: deptrac: layers: - name: Foo collectors: - type: uses value: 'App\\SomeTrait' private: true This means that tokens collected by this specific collector can be referenced only by other tokens in the same layer. References from other layers will be considered violations, even if they would normally be allowed by configured ruleset. This can be useful at least in 2 cases: - External library that should be used only by one particular layer - In this case, you might via vendor include a library that should be used only by this particular layer and nobody else. - Layer that has a public API and private implementation - You might want to provide only a few classes to be available to use by other layers (public API) that call the internal implementation of the layer that on the other hand should not be available to anybody else other than the public API of the layer.","title":"Extra collector configuration"},{"location":"concepts/","text":"Core concepts At the heart of Deptrac are three main concepts: Layers are groups of classes that you define Rulesets Describe whether which layers a layer can communicate with, i.e. which classes are allowed in that layer Violations show when a layer uses classes from another layer that is forbidden by the currently configured rulesets. Layers Deptrac allows you to group different tokens(classes, function, file usage outside those) into layers . Technically layers are nothing more than a collection of those tokens. Each layer has a unique name and a list of one or more collectors, which will look for tokens should be assigned to this layer (and yes, tokens can be assigned to more than one layer). If you want to ensure your application follows the MVC architecture pattern then you can create a config file that makes sure a View does not directly interact with a Controller or that Models are independent of both Views and Controllers. Another example for layers are bundles in Symfony applications. Each bundle should be independent by design. You can create layers for each bundle you have in your application and then ensure that they do not use tokens from any of the other bundles. This is particularly helpful when you have an application with many bundles as it will tell you which ones to consolidate and which ones can be extracted and reused. Deptrac allows you to visualize and enforce a ruleset based on such layer information. So you could define that every class that ends with Controller will be assigned to the Controller layer, and every class that has \\Model\\ in its namespace will be added to the Model layer. By default, all dependencies between layers are forbidden! Collecting Layers If your application has controllers and models , Deptrac allows you to group them into layers. deptrac: paths: - ./examples/ModelController exclude_files: ~ layers: - name: Models collectors: - type: className value: .*MyNamespace\\\\Models\\\\.* - name: Controller collectors: - type: className value: .*MyNamespace\\\\.*Controller.* ruleset: [ ] At first, lets take a closer look at the first layer (named Models ). Here we decided that our software has some kind of layer called Models . You assign tokens to this layer with the help of Collectors . Collectors are responsible for taking a closer look at your code and decide if a token is part of a layer. By using the className collector you can define a regular expression for a class name. Every (fully qualified) class name that matches this regular expression becomes part of the assigned layer. In this example we define that every class that contains MyNamespace\\Models\\ will be a part of the Model layer. Every class that matches .*MyNamespace\\\\.*Controller.* will become a part of the Controller layer. As we defined our layers, we can generate a dependency graph for the example configuration: (Make sure that Graphviz (dot) is installed on your system) php deptrac.phar analyse --config-file=examples/ModelController1.depfile.yaml After Deptrac has finished, an image should be opened: On your command line Deptrac will produce this output: Start to create an AstMap for 2 Files. .. AstMap created. start emitting dependencies \"InheritanceDependencyEmitter\" start emitting dependencies \"BasicDependencyEmitter\" end emitting dependencies start flatten dependencies end flatten dependencies collecting violations. formatting dependencies. Found 0 Violations The output shows, that Deptrac is parsing 2 files and found 0 violations. By default, every dependency between layers is a violation. In our case there are (for now) no dependencies between our classes (layers). It's fine that Deptrac will show us two independent layers without any relationship. Ruleset (Allowing Dependencies) Allowed dependencies between layers are configured in a ruleset . By default, Deptrac will raise a violation for every dependency between layers. In real software you want to allow dependencies between different kinds of layers. As a lot of architectures define some kind of controllers , services and repositories , a natural approach for this would be to define these rules: Controllers may access services , but not repositories . Services may access repositories , but not controllers . Repositories neither may access services nor controllers . We can define this using the following configuration: # deptrac.yaml deptrac: paths: - ./examples/ControllerServiceRepository1/ exclude_files: ~ layers: - name: Controller collectors: - type: className value: .*MyNamespace\\\\.*Controller.* - name: Repository collectors: - type: className value: .*MyNamespace\\\\.*Repository.* - name: Service collectors: - type: className value: .*MyNamespace\\\\.*Service.* ruleset: Controller: - Service Service: - Repository Repository: ~ Take a closer look at the ruleset. We allow the Controller layer to access Service and Service can access Repository , but Repository may not access any of the two other layers. After running Deptrac we will get this result: Start to create an AstMap for 3 Files. ... AstMap created. start emitting dependencies \"InheritanceDependencyEmitter\" start emitting dependencies \"BasicDependencyEmitter\" end emitting dependencies start flatten dependencies end flatten dependencies collecting violations. formatting dependencies. examples\\MyNamespace\\Repository\\SomeRepository::5 must not depend on examples\\MyNamespace\\Controllers\\SomeController (Repository on Controller) Deptrac now finds a violation. If we take a closer look at the \"SomeRepository\" on line 5, we will see an unused use statement for a controller: namespace examples\\MyNamespace\\Repository; use examples\\MyNamespace\\Controllers\\SomeController; class SomeRepository { } If we remove the use statement and rerun Deptrac, the violation will disappear. Different Layers and Different Views In the example above we defined 3 different layers ( controller , repository and service ). Deptrac gives architects the power to define what kind of layers exist. Typical use cases are: caring about layers in different architectures (tier, hexagonal, ddd, ...) caring about dependencies between different kinds of services (infrastructure services / domain services / entities / DTOs / ...) caring about coupling to third party code like composer vendors, frameworks, ... enforcing naming conventions ... Typically software has more than just one view. It is possible to use multiple config files, to take care about different architectural views. Uncovered dependencies Deptrac collects uncovered dependencies which can be reported with the Console Formatter . By default, internal php classes will not be considered. This can be changed by adding ignore_uncovered_internal_classes: false to your configuration. You can use the --fail-on-uncovered option to let Deptrac fail when any uncovered dependencies are encountered. You can use the --report-uncovered option to let you know about any uncovered dependencies in the report that is generated by Deptrac. @internal and @deptrac-internal annotation You can mark your classes with @internal or @deptrac-internal annotation. If you do so, the marked class cannot be referenced by any class outside its layer. This will supersede any ruleset configuration you might have defined. This way, you don't have to define 2 separate layers to distinguish between layers external API and its private implementation. Violations If we have 2 layers ( Models , Controller ) and one layer is using the other, Deptrac will raise a violation by default: // see the example in examples/ModelController2 namespace examples\\MyNamespace\\Controllers; use examples\\MyNamespace\\Models\\SomeModel; class SomeController { public function foo(SomeModel $m) { return $m; } } After running Deptrac for this example php deptrac.phar analyse --config-file=examples/ModelController2.depfile.yaml we will get this output: Start to create an AstMap for 2 Files. .. AstMap created. start emitting dependencies \"InheritanceDependencyEmitter\" start emitting dependencies \"BasicDependencyEmitter\" end emitting dependencies start flatten dependencies end flatten dependencies collecting violations. formatting dependencies. examples\\MyNamespace\\Controllers\\SomeController::5 must not depend on examples\\MyNamespace\\Models\\SomeModel (Controller on Models) examples\\MyNamespace\\Controllers\\SomeController::9 must not depend on examples\\MyNamespace\\Models\\SomeModel (Controller on Models) Found 2 Violations Deptrac has found two violations because the relation from the controller to model layers is not allowed. The console output shows exactly the lines Deptrac found. Skip violations Deptrac integration into existing CI/CD pipeline might be difficult because of existing dependency violations in the code. In this case, you can skip existing violations to gradually improve your code and avoid possibility introduce any new violations. Violations can be skipped by provided list of dependencies in skip_violations configuration section: deptrac: skip_violations: Library\\LibClass: - Core\\CoreClass skip_violations section contains an associative array where a key ( Library\\LibClass ) is the name of dependant token and values ( Core\\CoreClass ) are dependency tokens. Matched violations will be marked as skipped: php deptrac.phar analyse --config-file=examples/SkipViolations.yaml --report-skipped 1/1 [\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593] 100% [SKIPPED] Library\\LibClass must not depend on Core\\CoreClass (Library on Core) /path/examples/SkipViolations/SkipViolations.php::11 [ERROR] Skipped violation \"Core\\Unmatched\" for \"Library\\LibClass\" was not matched. Report: Violations: 0 Skipped violations: 1 Uncovered: 0 Allowed: 1","title":"Concepts"},{"location":"concepts/#core-concepts","text":"At the heart of Deptrac are three main concepts: Layers are groups of classes that you define Rulesets Describe whether which layers a layer can communicate with, i.e. which classes are allowed in that layer Violations show when a layer uses classes from another layer that is forbidden by the currently configured rulesets.","title":"Core concepts"},{"location":"concepts/#layers","text":"Deptrac allows you to group different tokens(classes, function, file usage outside those) into layers . Technically layers are nothing more than a collection of those tokens. Each layer has a unique name and a list of one or more collectors, which will look for tokens should be assigned to this layer (and yes, tokens can be assigned to more than one layer). If you want to ensure your application follows the MVC architecture pattern then you can create a config file that makes sure a View does not directly interact with a Controller or that Models are independent of both Views and Controllers. Another example for layers are bundles in Symfony applications. Each bundle should be independent by design. You can create layers for each bundle you have in your application and then ensure that they do not use tokens from any of the other bundles. This is particularly helpful when you have an application with many bundles as it will tell you which ones to consolidate and which ones can be extracted and reused. Deptrac allows you to visualize and enforce a ruleset based on such layer information. So you could define that every class that ends with Controller will be assigned to the Controller layer, and every class that has \\Model\\ in its namespace will be added to the Model layer. By default, all dependencies between layers are forbidden!","title":"Layers"},{"location":"concepts/#collecting-layers","text":"If your application has controllers and models , Deptrac allows you to group them into layers. deptrac: paths: - ./examples/ModelController exclude_files: ~ layers: - name: Models collectors: - type: className value: .*MyNamespace\\\\Models\\\\.* - name: Controller collectors: - type: className value: .*MyNamespace\\\\.*Controller.* ruleset: [ ] At first, lets take a closer look at the first layer (named Models ). Here we decided that our software has some kind of layer called Models . You assign tokens to this layer with the help of Collectors . Collectors are responsible for taking a closer look at your code and decide if a token is part of a layer. By using the className collector you can define a regular expression for a class name. Every (fully qualified) class name that matches this regular expression becomes part of the assigned layer. In this example we define that every class that contains MyNamespace\\Models\\ will be a part of the Model layer. Every class that matches .*MyNamespace\\\\.*Controller.* will become a part of the Controller layer. As we defined our layers, we can generate a dependency graph for the example configuration: (Make sure that Graphviz (dot) is installed on your system) php deptrac.phar analyse --config-file=examples/ModelController1.depfile.yaml After Deptrac has finished, an image should be opened: On your command line Deptrac will produce this output: Start to create an AstMap for 2 Files. .. AstMap created. start emitting dependencies \"InheritanceDependencyEmitter\" start emitting dependencies \"BasicDependencyEmitter\" end emitting dependencies start flatten dependencies end flatten dependencies collecting violations. formatting dependencies. Found 0 Violations The output shows, that Deptrac is parsing 2 files and found 0 violations. By default, every dependency between layers is a violation. In our case there are (for now) no dependencies between our classes (layers). It's fine that Deptrac will show us two independent layers without any relationship.","title":"Collecting Layers"},{"location":"concepts/#ruleset-allowing-dependencies","text":"Allowed dependencies between layers are configured in a ruleset . By default, Deptrac will raise a violation for every dependency between layers. In real software you want to allow dependencies between different kinds of layers. As a lot of architectures define some kind of controllers , services and repositories , a natural approach for this would be to define these rules: Controllers may access services , but not repositories . Services may access repositories , but not controllers . Repositories neither may access services nor controllers . We can define this using the following configuration: # deptrac.yaml deptrac: paths: - ./examples/ControllerServiceRepository1/ exclude_files: ~ layers: - name: Controller collectors: - type: className value: .*MyNamespace\\\\.*Controller.* - name: Repository collectors: - type: className value: .*MyNamespace\\\\.*Repository.* - name: Service collectors: - type: className value: .*MyNamespace\\\\.*Service.* ruleset: Controller: - Service Service: - Repository Repository: ~ Take a closer look at the ruleset. We allow the Controller layer to access Service and Service can access Repository , but Repository may not access any of the two other layers. After running Deptrac we will get this result: Start to create an AstMap for 3 Files. ... AstMap created. start emitting dependencies \"InheritanceDependencyEmitter\" start emitting dependencies \"BasicDependencyEmitter\" end emitting dependencies start flatten dependencies end flatten dependencies collecting violations. formatting dependencies. examples\\MyNamespace\\Repository\\SomeRepository::5 must not depend on examples\\MyNamespace\\Controllers\\SomeController (Repository on Controller) Deptrac now finds a violation. If we take a closer look at the \"SomeRepository\" on line 5, we will see an unused use statement for a controller: namespace examples\\MyNamespace\\Repository; use examples\\MyNamespace\\Controllers\\SomeController; class SomeRepository { } If we remove the use statement and rerun Deptrac, the violation will disappear.","title":"Ruleset (Allowing Dependencies)"},{"location":"concepts/#different-layers-and-different-views","text":"In the example above we defined 3 different layers ( controller , repository and service ). Deptrac gives architects the power to define what kind of layers exist. Typical use cases are: caring about layers in different architectures (tier, hexagonal, ddd, ...) caring about dependencies between different kinds of services (infrastructure services / domain services / entities / DTOs / ...) caring about coupling to third party code like composer vendors, frameworks, ... enforcing naming conventions ... Typically software has more than just one view. It is possible to use multiple config files, to take care about different architectural views.","title":"Different Layers and Different Views"},{"location":"concepts/#uncovered-dependencies","text":"Deptrac collects uncovered dependencies which can be reported with the Console Formatter . By default, internal php classes will not be considered. This can be changed by adding ignore_uncovered_internal_classes: false to your configuration. You can use the --fail-on-uncovered option to let Deptrac fail when any uncovered dependencies are encountered. You can use the --report-uncovered option to let you know about any uncovered dependencies in the report that is generated by Deptrac.","title":"Uncovered dependencies"},{"location":"concepts/#internal-and-deptrac-internal-annotation","text":"You can mark your classes with @internal or @deptrac-internal annotation. If you do so, the marked class cannot be referenced by any class outside its layer. This will supersede any ruleset configuration you might have defined. This way, you don't have to define 2 separate layers to distinguish between layers external API and its private implementation.","title":"@internal and @deptrac-internal annotation"},{"location":"concepts/#violations","text":"If we have 2 layers ( Models , Controller ) and one layer is using the other, Deptrac will raise a violation by default: // see the example in examples/ModelController2 namespace examples\\MyNamespace\\Controllers; use examples\\MyNamespace\\Models\\SomeModel; class SomeController { public function foo(SomeModel $m) { return $m; } } After running Deptrac for this example php deptrac.phar analyse --config-file=examples/ModelController2.depfile.yaml we will get this output: Start to create an AstMap for 2 Files. .. AstMap created. start emitting dependencies \"InheritanceDependencyEmitter\" start emitting dependencies \"BasicDependencyEmitter\" end emitting dependencies start flatten dependencies end flatten dependencies collecting violations. formatting dependencies. examples\\MyNamespace\\Controllers\\SomeController::5 must not depend on examples\\MyNamespace\\Models\\SomeModel (Controller on Models) examples\\MyNamespace\\Controllers\\SomeController::9 must not depend on examples\\MyNamespace\\Models\\SomeModel (Controller on Models) Found 2 Violations Deptrac has found two violations because the relation from the controller to model layers is not allowed. The console output shows exactly the lines Deptrac found.","title":"Violations"},{"location":"concepts/#skip-violations","text":"Deptrac integration into existing CI/CD pipeline might be difficult because of existing dependency violations in the code. In this case, you can skip existing violations to gradually improve your code and avoid possibility introduce any new violations. Violations can be skipped by provided list of dependencies in skip_violations configuration section: deptrac: skip_violations: Library\\LibClass: - Core\\CoreClass skip_violations section contains an associative array where a key ( Library\\LibClass ) is the name of dependant token and values ( Core\\CoreClass ) are dependency tokens. Matched violations will be marked as skipped: php deptrac.phar analyse --config-file=examples/SkipViolations.yaml --report-skipped 1/1 [\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593] 100% [SKIPPED] Library\\LibClass must not depend on Core\\CoreClass (Library on Core) /path/examples/SkipViolations/SkipViolations.php::11 [ERROR] Skipped violation \"Core\\Unmatched\" for \"Library\\LibClass\" was not matched. Report: Violations: 0 Skipped violations: 1 Uncovered: 0 Allowed: 1","title":"Skip violations"},{"location":"configuration/","text":"Configuration The configuration file describes your layers, ruleset and adjusts output formatting. We suggest you also check out Deptrac's configuration for checking its own architecture as it uses most available options. Deptrac The following table shows the available config keys for Deptrac. Property Path Input description Example usage analyser.types A list with at least one of the following supported dependency types: class default \u2014 analyses class definitions for everything apart from superglobal usage. class_superglobal \u2014 analyses class definitions for superglobal usage. use default \u2014 analyses file definitions for use statements. file \u2014 analyses file for everything apart from use statements and function/class definitions. function \u2014 analyses function definitions for everything apart from superglobal usage. function_superglobal \u2014 analyses function definitions for superglobal usage. function_call \u2014 analyses calls to custom(user-defined) functions deptrac: analyser: types: - \"use\" - \"file\" - \"class_superglobal\" - \"function_superglobal\" - \"function_call\" paths List of paths where Deptrac should look for dependencies to be analysed. Usually, this is where your code is stored, e.g. src/ , or lib/ or something similar. deptrac: paths: - src/ exlcude_files A list of regular expression-patterns to determine which files to exclude, e.g. test files or config deptrac: exclude_files: - '#.*Test\\.php$#' formatters.graphviz.groups Key is the name of the group and values are the layers belonging to that group deptrac: formatters: graphviz: groups: Entrypoints: - Controllers - Commands Persistence: - Repositories - Entities formatters.graphviz.hidden_layers List of layers to be excluded from the Graphviz output deptrac: formatters: graphviz: hidden_layers: - Controllers formatters.codeclimate.severity Assigns a severity to each section reported by Deptrac. The following severity types are supported by codeclimate: info minor major critical blocker deptrac: formatters: codeclimate: severity: failure: blocker skipped: major uncovered: major deptrac.ignore_uncovered_internal_classes Whether PHP-internal classes like DateTimeImmutable should count towards uncovered classes, when they are not part of any layer. deptrac: ignore_uncovered_internal_classes: false # default: true deptrac.layers Defines your architectural layers by collecting dependencies using collectors deptrac: layers: - name: Controller collectors: - type: className value: .*Controller.* deptrac.ruleset Assign communication rules by specifying which layers a layer can communicate with (if any). If you prepend a layer with + then not only this layer is allowed, but also all layers it allows. deptrac: ruleset: Controllers: [Services] Services: - Repositories Repositories: ~ deptrac.skip_violations Define a dictionary of dependencies and their known violations. This violations will be ignored in your pipeline and not trigger a failing return code. deptrac: skip_violations: Library\\LibClass: - Core\\CoreClass Imports If your config file becomes too large, you can split it up into multiple files that can then be imported in the main file using the imports section. This is also useful to separate your baseline from the rest of the configuration, so it can be regenerated by the baseline formatter. Example: imports: - deptrac.baseline.yaml Services Please see Symfony docs . This allows you to register new services, e.g. custom formatters or collectors. services: - class: Internal\\Qossmic\\Deptrac\\IgnoreDependenciesOnContract tags: - { name: kernel.event_listener, event: Qossmic\\Deptrac\\Contract\\Analyser\\ProcessEvent } Parameters Deptrac provides parameters that can be user in your configuration. %currentWorkingDirectory% The path Deptrac runs in %depfileDirectory% The path where the configuration is stored. %projectDirectory% usually points to %depfileDirectory% %deptrac.cache_file% contains the filename and path for the cache file. Note: This parameter is set by --cache-file= and will be overwritten. You can specify your own parameters and reuse them in your configuration: Example: parameters: Project: MyProject deptrac: layers: - name: Foo collectors: - type: implements value: '%Project%\\SomeInterface'","title":"Configuration"},{"location":"configuration/#configuration","text":"The configuration file describes your layers, ruleset and adjusts output formatting. We suggest you also check out Deptrac's configuration for checking its own architecture as it uses most available options.","title":"Configuration"},{"location":"configuration/#deptrac","text":"The following table shows the available config keys for Deptrac. Property Path Input description Example usage analyser.types A list with at least one of the following supported dependency types: class default \u2014 analyses class definitions for everything apart from superglobal usage. class_superglobal \u2014 analyses class definitions for superglobal usage. use default \u2014 analyses file definitions for use statements. file \u2014 analyses file for everything apart from use statements and function/class definitions. function \u2014 analyses function definitions for everything apart from superglobal usage. function_superglobal \u2014 analyses function definitions for superglobal usage. function_call \u2014 analyses calls to custom(user-defined) functions deptrac: analyser: types: - \"use\" - \"file\" - \"class_superglobal\" - \"function_superglobal\" - \"function_call\" paths List of paths where Deptrac should look for dependencies to be analysed. Usually, this is where your code is stored, e.g. src/ , or lib/ or something similar. deptrac: paths: - src/ exlcude_files A list of regular expression-patterns to determine which files to exclude, e.g. test files or config deptrac: exclude_files: - '#.*Test\\.php$#' formatters.graphviz.groups Key is the name of the group and values are the layers belonging to that group deptrac: formatters: graphviz: groups: Entrypoints: - Controllers - Commands Persistence: - Repositories - Entities formatters.graphviz.hidden_layers List of layers to be excluded from the Graphviz output deptrac: formatters: graphviz: hidden_layers: - Controllers formatters.codeclimate.severity Assigns a severity to each section reported by Deptrac. The following severity types are supported by codeclimate: info minor major critical blocker deptrac: formatters: codeclimate: severity: failure: blocker skipped: major uncovered: major deptrac.ignore_uncovered_internal_classes Whether PHP-internal classes like DateTimeImmutable should count towards uncovered classes, when they are not part of any layer. deptrac: ignore_uncovered_internal_classes: false # default: true deptrac.layers Defines your architectural layers by collecting dependencies using collectors deptrac: layers: - name: Controller collectors: - type: className value: .*Controller.* deptrac.ruleset Assign communication rules by specifying which layers a layer can communicate with (if any). If you prepend a layer with + then not only this layer is allowed, but also all layers it allows. deptrac: ruleset: Controllers: [Services] Services: - Repositories Repositories: ~ deptrac.skip_violations Define a dictionary of dependencies and their known violations. This violations will be ignored in your pipeline and not trigger a failing return code. deptrac: skip_violations: Library\\LibClass: - Core\\CoreClass","title":"Deptrac"},{"location":"configuration/#imports","text":"If your config file becomes too large, you can split it up into multiple files that can then be imported in the main file using the imports section. This is also useful to separate your baseline from the rest of the configuration, so it can be regenerated by the baseline formatter. Example: imports: - deptrac.baseline.yaml","title":"Imports"},{"location":"configuration/#services","text":"Please see Symfony docs . This allows you to register new services, e.g. custom formatters or collectors. services: - class: Internal\\Qossmic\\Deptrac\\IgnoreDependenciesOnContract tags: - { name: kernel.event_listener, event: Qossmic\\Deptrac\\Contract\\Analyser\\ProcessEvent }","title":"Services"},{"location":"configuration/#parameters","text":"Deptrac provides parameters that can be user in your configuration. %currentWorkingDirectory% The path Deptrac runs in %depfileDirectory% The path where the configuration is stored. %projectDirectory% usually points to %depfileDirectory% %deptrac.cache_file% contains the filename and path for the cache file. Note: This parameter is set by --cache-file= and will be overwritten. You can specify your own parameters and reuse them in your configuration: Example: parameters: Project: MyProject deptrac: layers: - name: Foo collectors: - type: implements value: '%Project%\\SomeInterface'","title":"Parameters"},{"location":"debugging/","text":"Debugging Deptrac provides a series of debug commands that help you identify issues in your config files. All commands output one issue per line and can therefore be easily combined with other tools like wc or grep . debug:layer With the debug:layer -command you can list all tokens which are matched in a specific layer. This command only shows tokens that would be emitted by your analyser configuration. php deptrac.phar debug:layer --config-file=examples/DirectoryLayer.depfile.yaml Layer1 examples\\Layer1\\AnotherClassLikeAController examples\\Layer1\\SomeClass examples\\Layer1\\SomeClass2 debug:token The debug:token (previously debug:class-like )-command will let you know which layers a specified token belongs to. Since you can specify the token type, this commands ignores your analyser configuration for emitted token types. php deptrac.phar debug:token --config-file=examples/DirectoryLayer.depfile.yaml 'examples\\Layer1\\AnotherClassLikeAController' class-like Controller Layer1 debug:unassigned With the debug:unassigned -command you list all tokens in your path that are not assigned to any layer. This is useful to test that your collector configuration for layers is correct. This command only shows tokens that would be emitted by your analyser configuration. php deptrac.phar debug:unassigned --config-file=examples/DirectoryLayer.depfile.yaml examples\\Layer1\\AnotherClassLikeAController examples\\Layer1\\SomeClass examples\\Layer1\\SomeClass2","title":"Debugging"},{"location":"debugging/#debugging","text":"Deptrac provides a series of debug commands that help you identify issues in your config files. All commands output one issue per line and can therefore be easily combined with other tools like wc or grep .","title":"Debugging"},{"location":"debugging/#debuglayer","text":"With the debug:layer -command you can list all tokens which are matched in a specific layer. This command only shows tokens that would be emitted by your analyser configuration. php deptrac.phar debug:layer --config-file=examples/DirectoryLayer.depfile.yaml Layer1 examples\\Layer1\\AnotherClassLikeAController examples\\Layer1\\SomeClass examples\\Layer1\\SomeClass2","title":"debug:layer"},{"location":"debugging/#debugtoken","text":"The debug:token (previously debug:class-like )-command will let you know which layers a specified token belongs to. Since you can specify the token type, this commands ignores your analyser configuration for emitted token types. php deptrac.phar debug:token --config-file=examples/DirectoryLayer.depfile.yaml 'examples\\Layer1\\AnotherClassLikeAController' class-like Controller Layer1","title":"debug:token"},{"location":"debugging/#debugunassigned","text":"With the debug:unassigned -command you list all tokens in your path that are not assigned to any layer. This is useful to test that your collector configuration for layers is correct. This command only shows tokens that would be emitted by your analyser configuration. php deptrac.phar debug:unassigned --config-file=examples/DirectoryLayer.depfile.yaml examples\\Layer1\\AnotherClassLikeAController examples\\Layer1\\SomeClass examples\\Layer1\\SomeClass2","title":"debug:unassigned"},{"location":"formatters/","text":"Formatters Deptrac has support for different output formatters with various options. You can get a list of available formatters by running php deptrac.php analyse --help Baseline Formatter The Baseline formatter is a console formatter, which generates the skip_violations section to the given File. With this formatter it's possible to start on a project with some violations without a failing CI Build. Note : It's not the best solution to ignore all the errors because maybe your current Architecture doesn't allow a change without a new violation. It can be activated with --formatter=baseline . Supported options: --output[=BASELINE-DUMP] path to a dumped baseline file [default: \"./deptrac.baseline.yaml\"] Don't forget to include the baseline into your existing deptrac.yaml # deptrac.yaml imports: - deptrac.baseline.yaml Console Formatter This formatter dumps basic information to STDOUT , examples\\MyNamespace\\Repository\\SomeRepository::5 must not depend on examples\\MyNamespace\\Controllers\\SomeController (Repository on Controller) GitHubActions Formatter The GithubActions formatter is a console formatter, which dumps basic information in github-actions format to STDOUT . This formatter is enabled by default while running in a GitHub actions environment. It can be activated manually with --formatter=github-actions . ::error file=/home/testuser/originalA.php,line=12::ACME\\OriginalA must not depend on ACME\\OriginalB (LayerA on LayerB) Graphviz Formatters There is a whole family of Graphviz formatters for you to choose from depending on what type of output you are expecting. They can be activated with: --formatter=graphviz-display Automatically tries to open the image --formatter=graphviz-dot Saves the output to a .dot file --formatter=graphviz-html Saves the output to a .html file --formatter=graphviz-image Saves the output to a supported image file format such as png, svg or jpg Supported options: --output= path to a dumped file Hide layers in output Under formatters.graphviz.hidden_layers you can define a list of layers you do not want to include when using the corresponding graphviz output formatter. The generated image will not contain these layers, but they will be part of the analysis. There are 2 main use-cases for this feature: Hiding a generic/general domains like the vendor folder Having multiple \"views\" for your architecture. You can define a shared file with all your layers and a ruleset and then have multiple config files for the different hidden_layers . Using the graphviz formatter with these files will then generate graphs focusing on only the relevant layers. deptrac: layers: - name: Utils collectors: - type: className value: .*Util.* - name: Controller collectors: - type: className value: .*Controller.* ruleset: Controller: - Utils formatters: graphviz: hidden_layers: - Utils Group layers Another supported option is formatters.graphviz.groups . There you can sort layers into groups that will be rendered as sub-graphs in GraphViz output. The following config: deptrac: layers: - User Frontend - User Backend - Admin Frontend - Admin Backend formatters: graphviz: groups: User: - User Frontend - User Backend Admin: - Admin Frontend - Admin Backend Will produce the following graph: Pointing to groups instead of nodes With formatters.graphviz.pointToGroups set to true , when you have a node inside a groups with the same name as the group itself, edges pointing to that node will point to the group instead. This might be useful for example if you want to provide a \"public API\" for a module defined by a group. JSON Formatter By default, Json formatter dumps information to STDOUT . It can be activated with --formatter=json { \"Report\": { \"Violations\": 1, \"Skipped violations\": 2, \"Uncovered\": 1, \"Allowed\": 0, \"Warnings\": 0, \"Errors\": 0 }, \"files\": { \"src/ClassA.php\": { \"violations\": 2, \"messages\": [ { \"message\": \"ClassA must not depend on ClassB (LayerA on LayerB)\", \"line\": 12, \"type\": \"error\" }, { \"message\": \"ClassA should not depend on ClassC (LayerA on LayerB)\", \"line\": 15, \"type\": \"warning\" } ] }, \"src/ClassC.php\": { \"violations\": 1, \"messages\": [ { \"message\": \"ClassC should not depend on ClassD (LayerA on LayerB)\", \"line\": 10, \"type\": \"warning\" } ] }, \"src/OriginalA.php\": { \"violations\": 1, \"messages\": [ { \"message\": \"OriginalA has uncovered dependency on OriginalB (LayerA)\", \"line\": 5, \"type\": \"warning\" } ] } } } Supported options: --output= path to a dumped json file JUnit Formatter The JUnit formatter dumps a JUnit Report XML file, which is quite handy in CI environments. It is disabled by default, to activate the formatter just use --formatter=junit . <?xml version=\"1.0\" encoding=\"UTF-8\"?> <testsuites> <testsuite id=\"1\" package=\"\" name=\"Controller\" timestamp=\"2018-06-07T10:09:34+00:00\" hostname=\"localhost\" tests=\"3\" failures=\"2\" errors=\"0\" time=\"0\"> <testcase name=\"Controller-examples\\Layer1\\AnotherClassLikeAController\" classname=\"examples\\Layer1\\AnotherClassLikeAController\" time=\"0\"> <failure message=\"examples\\Layer1\\AnotherClassLikeAController:5 must not depend on examples\\Layer2\\SomeOtherClass (Controller on Layer2)\" type=\"WARNING\" /> <failure message=\"examples\\Layer1\\AnotherClassLikeAController:23 must not depend on examples\\Layer2\\SomeOtherClass (Controller on Layer2)\" type=\"WARNING\" /> </testcase> </testsuite> <testsuite id=\"2\" package=\"\" name=\"Layer2\" timestamp=\"2018-06-07T10:09:34+00:00\" hostname=\"localhost\" tests=\"3\" failures=\"4\" errors=\"0\" time=\"0\"> <testcase name=\"Layer2-examples\\Layer2\\SomeOtherClass2\" classname=\"examples\\Layer2\\SomeOtherClass2\" time=\"0\"> <failure message=\"examples\\Layer2\\SomeOtherClass2:5 must not depend on examples\\Layer1\\SomeClass2 (Layer2 on Layer1)\" type=\"WARNING\" /> <failure message=\"examples\\Layer2\\SomeOtherClass2:17 must not depend on examples\\Layer1\\SomeClass2 (Layer2 on Layer1)\" type=\"WARNING\" /> </testcase> <testcase name=\"Layer2-examples\\Layer2\\SomeOtherClass\" classname=\"examples\\Layer2\\SomeOtherClass\" time=\"0\"> <failure message=\"examples\\Layer2\\SomeOtherClass:5 must not depend on examples\\Layer1\\SomeClass (Layer2 on Layer1)\" type=\"WARNING\" /> <failure message=\"examples\\Layer2\\SomeOtherClass:17 must not depend on examples\\Layer1\\SomeClass (Layer2 on Layer1)\" type=\"WARNING\" /> </testcase> </testsuite> </testsuites> Supported options: --output= path to a dumped xml file [default: \"./junit-report.xml\"] Table Formatter The default formatter is the table formatter, which groups results by layers to its own table. It can be also activated with --formatter=table . Codeclimate Formatter By default, Codeclimate formatter dumps information to STDOUT . It can be activated with --formatter=codeclimate This formatter is compatible with GitLab CI. Supported options: --output= path to a dumped file Change severity of a violation Under formatters.codeclimate.severity you can define which severity string you want to assign to a given violation type. By default, deptrac uses major for failures, minor for skipped violations and info for uncovered dependencies. deptrac: formatters: codeclimate: severity: failure: blocker skipped: minor uncovered: info Example issue raport [ { \"type\": \"issue\", \"check_name\": \"Dependency violation\", \"fingerprint\": \"3c6b66029bacb18446b7889430ec5aad7fae01cb\", \"description\": \"ClassA must not depend on ClassB (LayerA on LayerB)\", \"categories\": [\"Style\", \"Complexity\"], \"severity\": \"major\", \"location\": { \"path\": \"ClassA.php\", \"lines\": { \"begin\": 12 } } } ]","title":"Formatters"},{"location":"formatters/#formatters","text":"Deptrac has support for different output formatters with various options. You can get a list of available formatters by running php deptrac.php analyse --help","title":"Formatters"},{"location":"formatters/#baseline-formatter","text":"The Baseline formatter is a console formatter, which generates the skip_violations section to the given File. With this formatter it's possible to start on a project with some violations without a failing CI Build. Note : It's not the best solution to ignore all the errors because maybe your current Architecture doesn't allow a change without a new violation. It can be activated with --formatter=baseline . Supported options: --output[=BASELINE-DUMP] path to a dumped baseline file [default: \"./deptrac.baseline.yaml\"] Don't forget to include the baseline into your existing deptrac.yaml # deptrac.yaml imports: - deptrac.baseline.yaml","title":"Baseline Formatter"},{"location":"formatters/#console-formatter","text":"This formatter dumps basic information to STDOUT , examples\\MyNamespace\\Repository\\SomeRepository::5 must not depend on examples\\MyNamespace\\Controllers\\SomeController (Repository on Controller)","title":"Console Formatter"},{"location":"formatters/#githubactions-formatter","text":"The GithubActions formatter is a console formatter, which dumps basic information in github-actions format to STDOUT . This formatter is enabled by default while running in a GitHub actions environment. It can be activated manually with --formatter=github-actions . ::error file=/home/testuser/originalA.php,line=12::ACME\\OriginalA must not depend on ACME\\OriginalB (LayerA on LayerB)","title":"GitHubActions Formatter"},{"location":"formatters/#graphviz-formatters","text":"There is a whole family of Graphviz formatters for you to choose from depending on what type of output you are expecting. They can be activated with: --formatter=graphviz-display Automatically tries to open the image --formatter=graphviz-dot Saves the output to a .dot file --formatter=graphviz-html Saves the output to a .html file --formatter=graphviz-image Saves the output to a supported image file format such as png, svg or jpg Supported options: --output= path to a dumped file","title":"Graphviz Formatters"},{"location":"formatters/#hide-layers-in-output","text":"Under formatters.graphviz.hidden_layers you can define a list of layers you do not want to include when using the corresponding graphviz output formatter. The generated image will not contain these layers, but they will be part of the analysis. There are 2 main use-cases for this feature: Hiding a generic/general domains like the vendor folder Having multiple \"views\" for your architecture. You can define a shared file with all your layers and a ruleset and then have multiple config files for the different hidden_layers . Using the graphviz formatter with these files will then generate graphs focusing on only the relevant layers. deptrac: layers: - name: Utils collectors: - type: className value: .*Util.* - name: Controller collectors: - type: className value: .*Controller.* ruleset: Controller: - Utils formatters: graphviz: hidden_layers: - Utils","title":"Hide layers in output"},{"location":"formatters/#group-layers","text":"Another supported option is formatters.graphviz.groups . There you can sort layers into groups that will be rendered as sub-graphs in GraphViz output. The following config: deptrac: layers: - User Frontend - User Backend - Admin Frontend - Admin Backend formatters: graphviz: groups: User: - User Frontend - User Backend Admin: - Admin Frontend - Admin Backend Will produce the following graph:","title":"Group layers"},{"location":"formatters/#pointing-to-groups-instead-of-nodes","text":"With formatters.graphviz.pointToGroups set to true , when you have a node inside a groups with the same name as the group itself, edges pointing to that node will point to the group instead. This might be useful for example if you want to provide a \"public API\" for a module defined by a group.","title":"Pointing to groups instead of nodes"},{"location":"formatters/#json-formatter","text":"By default, Json formatter dumps information to STDOUT . It can be activated with --formatter=json { \"Report\": { \"Violations\": 1, \"Skipped violations\": 2, \"Uncovered\": 1, \"Allowed\": 0, \"Warnings\": 0, \"Errors\": 0 }, \"files\": { \"src/ClassA.php\": { \"violations\": 2, \"messages\": [ { \"message\": \"ClassA must not depend on ClassB (LayerA on LayerB)\", \"line\": 12, \"type\": \"error\" }, { \"message\": \"ClassA should not depend on ClassC (LayerA on LayerB)\", \"line\": 15, \"type\": \"warning\" } ] }, \"src/ClassC.php\": { \"violations\": 1, \"messages\": [ { \"message\": \"ClassC should not depend on ClassD (LayerA on LayerB)\", \"line\": 10, \"type\": \"warning\" } ] }, \"src/OriginalA.php\": { \"violations\": 1, \"messages\": [ { \"message\": \"OriginalA has uncovered dependency on OriginalB (LayerA)\", \"line\": 5, \"type\": \"warning\" } ] } } } Supported options: --output= path to a dumped json file","title":"JSON Formatter"},{"location":"formatters/#junit-formatter","text":"The JUnit formatter dumps a JUnit Report XML file, which is quite handy in CI environments. It is disabled by default, to activate the formatter just use --formatter=junit . <?xml version=\"1.0\" encoding=\"UTF-8\"?> <testsuites> <testsuite id=\"1\" package=\"\" name=\"Controller\" timestamp=\"2018-06-07T10:09:34+00:00\" hostname=\"localhost\" tests=\"3\" failures=\"2\" errors=\"0\" time=\"0\"> <testcase name=\"Controller-examples\\Layer1\\AnotherClassLikeAController\" classname=\"examples\\Layer1\\AnotherClassLikeAController\" time=\"0\"> <failure message=\"examples\\Layer1\\AnotherClassLikeAController:5 must not depend on examples\\Layer2\\SomeOtherClass (Controller on Layer2)\" type=\"WARNING\" /> <failure message=\"examples\\Layer1\\AnotherClassLikeAController:23 must not depend on examples\\Layer2\\SomeOtherClass (Controller on Layer2)\" type=\"WARNING\" /> </testcase> </testsuite> <testsuite id=\"2\" package=\"\" name=\"Layer2\" timestamp=\"2018-06-07T10:09:34+00:00\" hostname=\"localhost\" tests=\"3\" failures=\"4\" errors=\"0\" time=\"0\"> <testcase name=\"Layer2-examples\\Layer2\\SomeOtherClass2\" classname=\"examples\\Layer2\\SomeOtherClass2\" time=\"0\"> <failure message=\"examples\\Layer2\\SomeOtherClass2:5 must not depend on examples\\Layer1\\SomeClass2 (Layer2 on Layer1)\" type=\"WARNING\" /> <failure message=\"examples\\Layer2\\SomeOtherClass2:17 must not depend on examples\\Layer1\\SomeClass2 (Layer2 on Layer1)\" type=\"WARNING\" /> </testcase> <testcase name=\"Layer2-examples\\Layer2\\SomeOtherClass\" classname=\"examples\\Layer2\\SomeOtherClass\" time=\"0\"> <failure message=\"examples\\Layer2\\SomeOtherClass:5 must not depend on examples\\Layer1\\SomeClass (Layer2 on Layer1)\" type=\"WARNING\" /> <failure message=\"examples\\Layer2\\SomeOtherClass:17 must not depend on examples\\Layer1\\SomeClass (Layer2 on Layer1)\" type=\"WARNING\" /> </testcase> </testsuite> </testsuites> Supported options: --output= path to a dumped xml file [default: \"./junit-report.xml\"]","title":"JUnit Formatter"},{"location":"formatters/#table-formatter","text":"The default formatter is the table formatter, which groups results by layers to its own table. It can be also activated with --formatter=table .","title":"Table Formatter"},{"location":"formatters/#codeclimate-formatter","text":"By default, Codeclimate formatter dumps information to STDOUT . It can be activated with --formatter=codeclimate This formatter is compatible with GitLab CI. Supported options: --output= path to a dumped file","title":"Codeclimate Formatter"},{"location":"formatters/#change-severity-of-a-violation","text":"Under formatters.codeclimate.severity you can define which severity string you want to assign to a given violation type. By default, deptrac uses major for failures, minor for skipped violations and info for uncovered dependencies. deptrac: formatters: codeclimate: severity: failure: blocker skipped: minor uncovered: info","title":"Change severity of a violation"},{"location":"formatters/#example-issue-raport","text":"[ { \"type\": \"issue\", \"check_name\": \"Dependency violation\", \"fingerprint\": \"3c6b66029bacb18446b7889430ec5aad7fae01cb\", \"description\": \"ClassA must not depend on ClassB (LayerA on LayerB)\", \"categories\": [\"Style\", \"Complexity\"], \"severity\": \"major\", \"location\": { \"path\": \"ClassA.php\", \"lines\": { \"begin\": 12 } } } ]","title":"Example issue raport"},{"location":"upgrade/","text":"Upgrade from 0.20 to 0.21 Depfile (Configuration File) In order to fix an issue where the same parameter from an imported file was being replaced instead of merged, we needed to reinstate the semantic configuration that was previously removed. We recommend switching back to semantic configuration, especially if you rely on imports. The following parameters can now be moved to deptrac: : paths exclude_files layers ruleset skip_violations formatters analyser use_relative_path_from_depfile ignore_uncovered_internal_classes The examples and documentation were updated accordingly. Upgrade from 0.19 to 0.20 Commands You must now use the new --config-file option instead of providing the configuration file (Depfile) as command argument Depfile (Configuration File) The baseline parameter was removed. You can use imports instead. The ruleset is no longer checked for undefined layers. They will be silently ignored instead. The parameter use_relative_path_from_depfile no longer exists. It is replaced by a projectDirectory parameter, which by default points to %depfileDirectory% and can be changed to %currentWorkingDirectory% or any other base directory you want to use as reference for relative paths. Baseline Formatter The default filename created by the baseline formatter changed. From: depfile.baseline.yml To: deptrac.baseline.yaml If you are not using the -o|--output= option, then you will end up with 2 files (old and new one) and likely import the old one in your main deptrac.yaml. You can avoid this by using the -o option or updating your deptrac.yaml and removing the old baseline file. Upgrade from 0.18 to 0.19 Depfile (Configuration File) What? The location of the default configuration file has changed. From: ./depfile.yaml To: ./deptrac.yaml The configuration inside the file must now be nested under parameters: except for imports. See docs for examples. How? In your depfile.yaml you can just add a new section parameters: at the top and then indent the remaining config 1 level under this section. The only exception is imports which should stay on its current level and should not be nested under parameters. Example: From: https://github.com/qossmic/deptrac/blob/0.18.0/depfile.yaml To: https://github.com/qossmic/deptrac/blob/0.19.0/deptrac.yaml After that, you can rename the file to deptrac.yaml to avoid the displayed warning and ensure the file will automatically be loaded in future versions. Alternatively you can keep your filename and make sure you load it via the new --config-file option in the relevant commands instead of as an argument. Why? In the future, we want to allow adding services to the configuration to extend Deptrac's functionality, e.g. by providing custom collectors. That is why we must separate the config into dedicated sections parameters and services.","title":"Upgrade Guide"},{"location":"upgrade/#upgrade-from-020-to-021","text":"","title":"Upgrade from 0.20 to 0.21"},{"location":"upgrade/#depfile-configuration-file","text":"In order to fix an issue where the same parameter from an imported file was being replaced instead of merged, we needed to reinstate the semantic configuration that was previously removed. We recommend switching back to semantic configuration, especially if you rely on imports. The following parameters can now be moved to deptrac: : paths exclude_files layers ruleset skip_violations formatters analyser use_relative_path_from_depfile ignore_uncovered_internal_classes The examples and documentation were updated accordingly.","title":"Depfile (Configuration File)"},{"location":"upgrade/#upgrade-from-019-to-020","text":"","title":"Upgrade from 0.19 to 0.20"},{"location":"upgrade/#commands","text":"You must now use the new --config-file option instead of providing the configuration file (Depfile) as command argument","title":"Commands"},{"location":"upgrade/#depfile-configuration-file_1","text":"The baseline parameter was removed. You can use imports instead. The ruleset is no longer checked for undefined layers. They will be silently ignored instead. The parameter use_relative_path_from_depfile no longer exists. It is replaced by a projectDirectory parameter, which by default points to %depfileDirectory% and can be changed to %currentWorkingDirectory% or any other base directory you want to use as reference for relative paths.","title":"Depfile (Configuration File)"},{"location":"upgrade/#baseline-formatter","text":"The default filename created by the baseline formatter changed. From: depfile.baseline.yml To: deptrac.baseline.yaml If you are not using the -o|--output= option, then you will end up with 2 files (old and new one) and likely import the old one in your main deptrac.yaml. You can avoid this by using the -o option or updating your deptrac.yaml and removing the old baseline file.","title":"Baseline Formatter"},{"location":"upgrade/#upgrade-from-018-to-019","text":"","title":"Upgrade from 0.18 to 0.19"},{"location":"upgrade/#depfile-configuration-file_2","text":"","title":"Depfile (Configuration File)"},{"location":"upgrade/#what","text":"The location of the default configuration file has changed. From: ./depfile.yaml To: ./deptrac.yaml The configuration inside the file must now be nested under parameters: except for imports. See docs for examples.","title":"What?"},{"location":"upgrade/#how","text":"In your depfile.yaml you can just add a new section parameters: at the top and then indent the remaining config 1 level under this section. The only exception is imports which should stay on its current level and should not be nested under parameters. Example: From: https://github.com/qossmic/deptrac/blob/0.18.0/depfile.yaml To: https://github.com/qossmic/deptrac/blob/0.19.0/deptrac.yaml After that, you can rename the file to deptrac.yaml to avoid the displayed warning and ensure the file will automatically be loaded in future versions. Alternatively you can keep your filename and make sure you load it via the new --config-file option in the relevant commands instead of as an argument.","title":"How?"},{"location":"upgrade/#why","text":"In the future, we want to allow adding services to the configuration to extend Deptrac's functionality, e.g. by providing custom collectors. That is why we must separate the config into dedicated sections parameters and services.","title":"Why?"}]}